# Redux

* redux is in charge of managing our application state
* state is a single plain js object
* application state is completely different and separate to component state
* reducers form application state
* reducers all get tied together by 'combineReducers' in the reducers/index.js file
* for each key in our combineReducers object, we assign one reducer
* and that reducer is responsible for creating this piece of state
* our reducers are in charge of changing our application state over time by the use of actions
* so whenever an action is dispatched it flows through all the different reducers in our application
* each reducer has the option to return a different piece of state than the usual, based on the type of action that was received
* action creators are just simple functions that return an action
* an action is just a plain js object
* actions must always have a type defined
* they can optionally have a payload or any other number of properties
* redux that's so simple, yes, but only simple once you actually understand what's going on.

npm i --save react-sparklines@1.6.0

## Review

* Redux constructs the app state,
* react the views to display that state
* use react-redux to connect the 2 libraries
* app state is generated by reducer functions
* we created 'reducer_books'
* always returns an array of books
* the array contains a list of objects
* each object represents one book
* we added this books reducer to our combineReducers call inside index, in the reducers folder
* this reducer is going to add a key to our global app state, called books, where the key is books and the value is whatever gets returned from the books reducer, in this case, our array of books
* our state is always going to be equal to an object with a key of books and a value of an array of books
* next, we created a component bookList,
* but needed to be aware of state, promoted to container
* by first importing the connect function from 'react-redux'
* and then defined mapStateToProps, and we hooked our component together with this and using the connect function
* we chose the component booklist to connect to the redux store because only booklist cares about the list of books
* finally, made sure app rendered booklist

```jsx
<BookList />
```

* redux generated a state object that contained our books,
* and then mapped that state as props to our component,
* because the state was updated through our reducer
* our component re rendered with that list of books
* whenever application state changes the container will re render as well
* a container is a component that gets bonded to the app state, and we connect or meld the 2 together
* whenever the app state changes the container will re render too

## Weather app

* openweathermap.org/forecast5
* middleware has ability to block, modify or let pass through actions as they are created before they hit a reducer.
* gatekeepers
* install redux-promise to help with the Ajax request
* npm install --save redux-promise
* we only change our application state through our reducers and actions
* to load our weather data we need to dispatch an action call
* call an action creator which is going to be responsible for making that ajax request
* inside actions/index.js to create an action creator that's going to be responsible for making an API request to go fetch our weather data
* create a new fn and export it so can be required into other files
* action creators always have to return an action
* an action is an object which always has to have a type
* define a variable called FETCH_WEATHER (rather than use a string)
* assign a string to it, and then exported that variable
* finally, created an action where the type was FETCH_WEATHER
* this way keeps our action types consistent between our action creators and our reducers
* going to create a reducer that handles this type FETCH_WEATHER
* what we , as a convention, is make a single variable that holds our action type and we use it in the action, then reference it in the reducer
* make new variable: const ROOT_URL = `http://api.openweathermap.org/data/2.5/forecast?appid=${API_KEY}`;
* use es6 template strings to clean up, backticks and ${API_kKEY}
* need to city from somewhere, so should always have an argument in the fetchWeather fn, of city which should be a string
* looking back at weather map site, in function:
  const url = `${ROOT_URL}&q=${city},uk`;
* we want to make a simple Ajax request with the axios library
* npm install --save axios
* is like jquery but simpler
* we need to make a get request, axios.get returns a promise
* import axios at top of file, then in theaction creator function:
* const request = axios.get(url);
* so take this url we crafted, with a particular search city and make a get request, this will return a promise, call it request
* going to pass that request into our action as the payload

```javascript
import axios from "axios";
//using es6 template strings ``
const API_KEY = "74511c527b1010d695024f17e6be9439";
const ROOT_URL = `http://api.openweathermap.org/data/2.5/forecast?appid=${API_KEY}`;

export const FETCH_WEATHER = "FETCH_WEATHER";

export function fetchWeather(city) {
  const url = `${ROOT_URL}&q=${city},uk`;
  const request = axios.get(url);
  return {
    type: FETCH_WEATHER,
    payload: request
  };
}
```

* we setup a new action creator called fetchWeather that's going to be reponsible for creating an action that contains a request to the backend API
* It's type was FETCH_WEATHER, the fetchWeather action creator takes a city, which is a string and uses it as part of the search query
* we installed the axios library, which behaves like jquery
* reaches out, does an ajax request in the form of a get url that we supply and returns a promise that we pass into the actions payload property.
*
